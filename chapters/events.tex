\chapter{Automating Observations of Transient Events}
\label{chap:events}
\chaptoc{}

% ########################################

\newpage
\section{Introduction}
\label{sec:events_intro}
\begin{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\begin{colsection}

In this chapter I outline my work on the systems that allow GOTO to automatically follow up alerts of transient events, specifically gravitational wave detections and gamma-ray bursts. Section~\ref{sec:gototile} describes the \software{Python} module GOTO-tile, which is used to create the all-sky grid that probability sky maps are mapped onto. The module was originally created by Darren White and then expanded by Evert Rol before I took over development, and the functions to create Gaussian sky maps were originally written by Yik Lun Mong. Section~\ref{sec:gotoalert} describes another \software{Python} module GOTO-alert, which contains the structures and functions to process alerts published by LIGO, NASA and other sources. This module was originally based on work by Alex Obradovic before I took over the code and developed it to work with the other GOTO modules. All work described in this chapter is my own and has not been published before anywhere else.

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\subsection{Transient astronomy}
\label{sec:transient_astronomy}
\begin{colsection}

For the last few decades the number of detections of transient astronomical sources has been rapidly increasing. From space-based gamma-ray burst monitors such as \textit{Fermi} and \textit{Swift} to wide-field survey telescopes such as the \gls{ptf} or \gls{asassn}, increasing numbers of time-critical events have been detected and therefore had to be rapidly sent to other observing partners for follow-up campaigns. Historically this was done, at a much slower pace, through physical post and telegrams --- hence the names of some of the current services offering modern, email-based alternatives: the Astronomer's Telegram \citep{ATel} GCN Circulars \citep{GCN}.

Today the global system has evolved to increasingly remove the human factor entirely in order to reduce the delay between events being detected and telescope observations being triggered. Robotic telescopes are now common and can be triggered automatically by machine processing of alerts generated automatically by the detection instruments. The \gls{ivoa} VOEvent protocol for transient alerts has become the standard language for such inter-robotic communications \citep{voevent}, allowing telescopes around to world to respond within seconds to transient alerts. Even then new projects such as the \gls{ztf}, itself paving the way for the imminent addition of the \gls{lsst}, will produce millions ove events per night requiring even faster and more efficient systems \citep{ZTF_alerts}.

GOTO's priority is of course detecting optical counterparts to gravitational wave events. Such events are published by the LIGO-Virgo Collaboration as VOEvents through the GCN Notice system, and the G-TeCS sentinel (see Section~\ref{sec:sentinel}) is the system in charge of listening for and acting on those events when they occur, adding new pointings to the observation database to trigger the counterpart search.

In order for the \gls{goto} imaging pipeline to identify new sources that might be related to a gravitational wave signal it needs previous observations of the same point in the sky to compare to. Therefore for a majority of the time \gls{goto} observes an all-sky survey corresponding to a fixed grid, to build up an archive of reference images. Then as new exposures are taken they can be compared to these references, allowing new sources to be detected through difference imaging (see Figure~\ref{fig:difference_imaging}).


\begin{figure}[t]
\includegraphics[width=\linewidth]{images/diffimg.pdf}
\caption[The detection of SN 2019bpc through difference imaging]{The detection of Type Ia supernova SN 2019bpc by the GOTOphoto difference imaging pipeline. The new exposure on the left (a) has the reference image (b) subtracted to give the difference image on the right (c), where the new source is clearly visible.}
\label{fig:difference_imaging}
\end{figure}


\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\end{colsection}

% ########################################

\newpage
\section{Tiling the sky with GOTO-tile}
\label{sec:gototile}
\begin{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\begin{colsection}

GOTO-tile is a \proglang{Python} module (\pkg{gototile} \rtxt{footnote url?}) created for the \gls{goto} project to contain all the functions and frameworks related to tiling the sky. It was originally developed by Darren White as a way to process \gls{ligo} \gls{gw} skymaps for \gls{goto}, and then maintained by Evert Rol who rearranged it into a module usable for some other telescopes including SuperWASP on La Palma and a proposed southern GOTO node. My contributions to the module have been more fundamental: reworking the foundations to improve how grids are defined and sky maps are applied to them, as well as adding different ways to create skymaps.

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\subsection{Creating sky grids}
\label{sec:grids}
% different ways to make grids
\begin{colsection}

The core of GOTO-tile as it now exists is the \code{SkyGrid} class. This is used to define a sky grid, a collection of `tiles' defined as points on the celestial sphere (Figure~\ref{fig:sphere}). These tiles are aligned to the celestial right ascension/declination coordinates, and are designed to create a base framework for observations to be mapped to.

The most important parameter required when defining a sky grid is the field of view of the telescope, which is taken as the size of the tiles that make up the grid. This is defined by giving a width and height value in degrees, meaning the tiles can only be square or rectangular. This is typically fine for the \gls{goto} array, although there was a period when having three \glspl{ut} in an `L'-shape was considered. This was abandoned due mainly to the complexity of tiling the grid based on abstract shapes.

The second parameter required to define a sky grid is the desired overlap between the tiles. This is given as a value between zero and one in both the right ascension and declination directions, with zero meaning no overlap and one meaning all the tiles are completely overlapping (as this would lead to infinite tiles being created in practice the overlap is restricted to no more than $0.9$). This is used to define the spacing between the tile centrers, although exactly how depends on the algorithm used.

As GOTO-tile has been developed the algorithm used to define tile centres has evolved and improved, but the basic method has remained the same:

\begin{enumerate}
    \item Define equally spaced lines of constant declination, separated by the value $\Delta\delta$ (Figure~\ref{fig:deltadelta}). These lines are the basis for the grid, which is defined in ``strips'' of tiles. Exactly how $\Delta\delta$ is defined based on the field of view and overlap parameters depends on the algorithm, in particular how to deal with the poles in case $\Delta\delta$ is not a factor of \SI{90}{\degree}.
    \item Once the strips are defined, then each is filled equally spaced points separated by the value $\Delta\alpha$ (Figure~\ref{fig:deltaalpha}). This value is constant for each strip but is (in most algorithms) a function of declination ($\Delta\alpha(\delta)$), meaning that moving away from the equator to the poles each strip will contain a reducing number of points.
    \item These points are then defined as the centre of the tiles, the size of which is given by the field of view (Figure~\ref{fig:tiledsphere}).
\end{enumerate}

Once the grid has been created it is encapsulated within the GOTO-tile \code{SkyGrid} class. Each tile is defined by a coordinate at its centre, and each is also given a unique name of the form \code{`T0001'}. The grid itself is also given a name formed using the input field of view and overlap parameters, so a grid created with a field of view of \SI{3.7}{\degree}$\times$\SI{4.9}{\degree} and overlap factor of 0.1 (this is the grid used for the \gls{goto} 4-\gls{ut} all-sky survey) is given the name \code{`allsky-3.7x4.9--0.1--0.1'}. In this way a given tile in a given grid can be recreated just from the names, which is used when storing the grid and tile details in the observation database (see Section~\ref{sec:obsdb}). % chktex 29

% ---------

\begin{figure}[p]
\begin{center}
\includegraphics[width=\linewidth]{images/globe1.pdf}
\end{center}
\caption[The celestial sphere]{The celestial sphere. The celestial equator is marked in \textcolor{red}{red}, the vernal equinox (where the ecliptic (not shown) crosses the equator) is marked with the symbol \Aries{} and the meridian that intercepts the vernal equinox is marked in \textcolor{blue}{blue}. The northern and southern celestial poles are marked as NCP and SCP respectively. The definition of the equatorial coordinate system is shown: declination (Dec, $\delta$) is defined as the angle from the equator, ranging from \SI{-90}{\degree} at the SCP to \SI{90}{\degree} at the NCP, and right ascension (RA, $\alpha$) is defined as angle east from the vernal equinox between \SI{0}{\degree} and \SI{360}{\degree}.
}
\label{fig:sphere}
\end{figure}

\begin{figure}[p]
\begin{center}
\includegraphics[width=\linewidth]{images/globe2.pdf}
\end{center}
\caption[Defining declination strips]{The first stage when creating a sky grid is defining the declination strips. This is done by dividing the full range of declination (\SI{-90}{\degree} to \SI{90}{\degree}) equally by a constant spacing value $\Delta\delta$. In this example $\Delta\delta =$ \SI{10}{\degree}, and so strips are defined at $\delta=$ \SI{0}{\degree}, \SI{10}{\degree}, \SI{20}{\degree} etc\ldots, and mirrored in the southern hemisphere. There is always a strip with $\delta=0$. Exactly how the strips are defined when $\Delta\delta$ is not an integer factor of \SI{90}{\degree} depends on the algorithm used, in this case using the ``minverlap'' algorithm the strips range from \SI{-90}{\degree} to \SI{90}{\degree} and include a ``strip'' at the poles which will contain single tile (as shown in Figure~\ref{fig:tiledsphere}).
}
\label{fig:deltadelta}
\end{figure}

\begin{figure}[p]
\begin{center}
\includegraphics[width=\linewidth]{images/globe3.pdf}
\end{center}
\caption[Defining the spacing between tiles]{After the declination strips are defined (see Figure~\ref{fig:deltadelta}) for each strip tile centres are defined with a set spacing $\Delta\alpha(\delta)$. Unlike $\Delta\delta$, which is fixed across the sphere, $\Delta\alpha$ varies as a function of declination meaning strips closer to the poles will contain fewer tiles. Two examples of defining tiles are shown above, one at declination $\delta_1$ (\SI{50}{\degree}, in \textcolor{cyan}{light blue}) in the northern hemisphere and another at $\delta_2$ (\SI{-10}{\degree}, in \textcolor{Plum}{purple}) in the southern hemisphere. The results of the ``minverlap'' algorithm are shown, previous algorithms had different ways of defining $\Delta\alpha$ that would have resulted in different spacings.
}
\label{fig:deltaalpha}
\end{figure}

\begin{figure}[p]
\begin{center}
\includegraphics[width=\linewidth]{images/globe4.pdf}
\end{center}
\caption[A fully tiled sphere]{Once every declination strip is complete the full grid is defined, as shown above. The same two strips are shown in \textcolor{cyan}{light blue} and \textcolor{Plum}{purple} as in Figure~\ref{fig:deltaalpha}. Due to each strip starting the tile spacing at RA$=0$, there is a fully aligned column of tiles along the vernal equinox, shown in \textcolor{orange}{yellow}. The grid in these examples was defined using the ``minverlap'' algorithm, with each tile having a field of view of \SI{10}{\degree} $\times$ \SI{10}{\degree} and the overlap was set to zero for clarity (note this can lead to gaps between tiles towards the poles, as visible here). In this case the complete grid contains 424 tiles.
}
\label{fig:tiledsphere}
\end{figure}

\newpage

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\subsection{Defining gridding algorithms}
\label{sec:algorithms}
\begin{colsection}

There have been three primary algorithms defined in GOTO-tile's history.

% ---------
\subsubsection{The product algorithm}

The first has since retroactively been called the ``\textbf{product}'' algorithm, and was used when Darren White first wrote GOTO-tile. It first defines the declination step size as

\begin{equation}
    \Delta\delta = f_\text{dec}(1-v_\text{dec}),
    \label{eq:product_deltadelta}
\end{equation}

where $f_\text{dec}$ and $v_\text{dec}$ are respectively the field of view and overlap parameters in the declination direction. The declination strips are then defined by taking steps of this size from the equator towards the poles, stopping when $|\delta| > 90$. The equivalent formula is used to calculate the steps in right ascension

\begin{equation}
    \Delta\alpha = f_\text{RA}(1-v_\text{RA}).
    \label{eq:product_deltaalpha}
\end{equation}

The clear downside of this method is that $\Delta\alpha$ does not vary depending on declination. In effect this algorithm attempts to define the grid as if it was on a flat plane, where the tiles could be arranged in orthogonal rows and columns. In practice when applied to a sphere this leads to a vast number of redundant tiles at the poles, as shown in Figure~\ref{fig:product}.

% ---------
\subsubsection{The cosine algorithm}

Due to the obvious problems with the previous algorithm a replacement was written by Evert Rol, which I have since called the ``\textbf{cosine}'' algorithm. It is a more refined version of the ``product'' algorithm, and the declination strips are calculated in the same manor using Equation~(\ref{eq:product_deltadelta}). However Equation~(\ref{eq:product_deltaalpha}) is modified to depend on declination into

\begin{equation}
    \Delta\alpha(\delta) = \frac{f_\text{RA}(1-v_\text{RA})}{\cos(\delta)}.
    \label{eq:cosine_deltaalpha}
\end{equation}

This produces a much more sensible grid as shown in Figure~\ref{fig:cosine}. However there remained an issue of asymmetry: the strips are arranged increasing and decreasing from $\delta=0$ and the tiles are then arranged within the strips starting from $\alpha=0$. As visible in Figure~\ref{fig:cosine} this leads to varying overlaps when the the tiles within the strips overlap as $\alpha$ approaches \SI{360}{\degree}. Although more subtle there are similar issues at the north and south poles, and it's common for there to be small gaps between the tiles at high and low declinations.

% ---------
\subsubsection{The minverlap algorithm}

Due to these problems I created a new method to create the grid, called the ``\textbf{minverlap}'' (minimum overlap) algorithm. The same grid created with this algorithm is shown in Figure~\ref{fig:minverlap}. The intention of the new algorithm was to solve these issues by adjusting the spacing between tiles to prevent odd gaps. The previous two algorithms both treat the given overlap parameter as as unegotiable, and if the resulting spacings don't give an integer number of tiles within the ranges available then there are uneven gaps at the edges. This is shown more clearly in Figure~\ref{fig:cosine_spacing}, where a tricky spacing results in gaps at the poles and variable overlaps on the meridian. The ``minverlap'' algorithm solves this by treating the given overlap parameter not as fixed but as the \textit{minimum} required overlap between tiles. If a grid is requested with an overlap of $0.2$ (20\%), but the odd field of view of the tiles doesn't fit neatly into the ranges then the overlap can be incensed until the tiles fit.

In order to do this mathematically, it is first necessary to find the number of tiles $n$ that would fit into the range using the previous spacing, and then if it isn't an integer number round it up to the next whole number. In declination this is calculated as

\begin{equation}
    n_\text{dec} = \left \lceil \frac{90}{f_\text{dec}(1-v_\text{dec})} \right \rceil,
    \label{eq:minverlap_ndec}
\end{equation}

where $\lceil x \rceil$ is the mathematical ceiling function. This is a modification of the previous Equation~(\ref{eq:product_deltadelta}) but one that will always find an integer number of tiles. For example, with $f_\text{dec} = $ \SI{13}{\degree} and $v_\text{dec} = 0.2$ the previous spacing $\Delta\delta = 13 \times (1-0.2) = $ \SI{10.4}{\degree}. This clearly doesn't divide into the \SI{90}{\degree} range without a remainder, which is \SI{6.8}{\degree} as shown in Figure~\ref{fig:cosine_spacing}. The problem is that \SI{90}{\degree} $/$ \SI{10.4}{\degree} $= 8.65$. So the previous algorithms will fit in 8 tiles and have over half a tile remaining at the poles. Instead the minverlap algorithm rounds this up to $n_\text{dec} = 9$ tiles, and then simply calculates the spacing using

\begin{equation}
    \Delta\delta = \frac{90}{n_\text{dec}}.
    \label{eq:minverlap_deltadelta}
\end{equation}

In this case the new $\Delta\delta = $ \SI{10}{\degree}, which gives an even arrangement of tiles from the equator to the poles, as shown in Figure~\ref{fig:minverlap_spacing}. The other benefit of this method is that, in addition to there always being a declination strip at $\delta=0$, there will always be ``strips'' at \SI{+90}{\degree} and \SI{-90}{\degree}, which results in a single tile being located covering the poles and ensuring there are no major gaps in coverage.

Right ascension is treated similarly. The integer number of tiles that can fit into a given declination strip is given by

\begin{equation}
    n_\text{RA}(\delta) = \left \lceil \frac{360}{f_\text{RA}(1-v_\text{RA})/\cos(\delta)} \right \rceil + 1,
    \label{eq:minverlap_nra}
\end{equation}

where the $+1$ is here necessary to account for tiles being located both at $\alpha=$\SI{0}{\degree} and $\alpha=$\SI{360}{\degree}. The logic is exactly the same as with declination, and the revised spacing is given by

\begin{equation}
    \Delta\alpha(\delta) = \frac{360}{n_\text{RA}(\delta)}.
    \label{eq:minverlap_deltaalpha}
\end{equation}

The effect of this is also shown in Figure~\ref{fig:minverlap_spacing}, and tiles are uniformly spaced around the declination strip. Note here the ceiling function does produce a slight degeneracy in $\Delta\alpha$ being a function of $\delta$. Using the same parameters as the previous example $\Delta\delta=$\SI{10}{\degree}, so declination strips start at \SI{0}{\degree} and continue to \SI{\pm10}{\degree}, \SI{\pm20}{\degree} \ldots (mirrored in both hemispheres). From Equation~(\ref{eq:minverlap_nra}) the number of tiles on the equator is $n_\text{RA}(\delta=\SI{0}{\degree}) = \lceil 360/(10.4/\cos(0)) \rceil + 1 = \lceil 34.6 \rceil + 1 = 36$. But on the next strip up (or down) $n_\text{RA}(\delta=\SI{\pm10}{\degree}) = \lceil 360/(10.4/\cos(\pm10)) \rceil + 1 = \lceil 34.1 \rceil + 1 = 36$ as well. This is a natural occurrence as there are only a limited number of ways to fit an integer number of fixed tiles into a given range, and so as shown in Figure~\ref{fig:minverlap} the three strips around the equator align perfectly with the same number of tiles.

% ---------
\subsubsection{Limitations of the minverlap algorithm}

The new ``minverlap'' algorithm is an improvement on the previous versions, in particular as it reduces the occurrences of gaps in coverage closer to the poles that happened when using the ``cosine'' algorithm. However the new algorithm is not perfect and gaps can still occur if the starting overlap parameter is very low. For example, Figure~\ref{fig:tiledsphere} shows a sphere tiled using the ``minverlap'' algorithm and an overlap parameter of 0. In this case gaps are visible in the strips of tiles just below the northern celestial pole. A proposed solution to this problem would be to force tiles to meet at their lower corners (in the northern hemisphere, upper corners in the south), therefore overlapping further and removing the possibility of gaps forming due to the angle between the tiles. An attempt to make this change and create an ``enhanced minverlap'' algorithm was tested, however ultimately it proved unnecessary. Although the current algorithm is deficient at low overlap values, this is only an issue for large tiles and very low overlaps. The \SI{10}{\degree} $\times$ \SI{10}{\degree} tiles and 0\% overlap used for Figure~\ref{fig:tiledsphere} are extreme values, and even for the roughly \SI{8}{\degree} $\times$ \SI{5}{\degree} full field of view of a full GOTO telescope the overlap has to be less than 10\% before noticeable gaps start appearing. As well, from the site on La Palma the northern celestial pole is actually below \glspl{goto} nominal horizon of \SI{30}{\degree}, therefore meaning tiles close to the pole will never be visible and the gaps in coverage were irrelevant. Should GOTO-tile be applied in the future to other projects then this issue would need to be revisited, but it was not a priority to fix within the context of this work.

% ---------

\begin{figure}[p]
\begin{minipage}[c]{0.46\textwidth}
\includegraphics[width=\linewidth]{images/algo_product.pdf}
\end{minipage}
\hfill
\begin{minipage}[c]{0.50\textwidth}
\caption[The ``product'' gridding algorithm]{A sky grid of tiles defined using the ``product'' gridding algorithm. The inputs were a field of view of \SI{13}{\degree} $\times$ \SI{13}{\degree} and an overlap factor of $0.2$ in both axes. The colours show overlapping coverage: \textcolor{Yellow}{yellow} areas are within only one tile, \textcolor{green}{green} two, \textcolor{blue}{blue} three, \textcolor{cyan}{cyan} four and \textcolor{RubineRed}{pink} five or more. This grid contains 595 tiles. Note the constant spacing of tiles in RA and the huge number of redundant tiles at the pole.}
\label{fig:product}
\end{minipage}
\end{figure}

\begin{figure}[p]
\begin{minipage}[c]{0.50\textwidth}
\caption[The ``cosine'' gridding algorithm]{A sky grid of tiles defined using the ``product'' gridding algorithm. The input parameters and colours are the same as in Figure~\ref{fig:product}. This grid contains 393 tiles. Note the asymmetric ``seam'' along the $\alpha=0$ meridian, and the \textcolor{red}{red} areas near the pole that are not within the area of any tiles.}
\label{fig:cosine}
\end{minipage}
\hfill
\begin{minipage}[c]{0.46\textwidth}
\includegraphics[width=\linewidth]{images/algo_cosine.pdf}
\end{minipage}
\end{figure}

\begin{figure}[p]
\begin{minipage}[c]{0.46\textwidth}
\includegraphics[width=\linewidth]{images/algo_minverlap.pdf}
\end{minipage}
\hfill
\begin{minipage}[c]{0.50\textwidth}
\caption[The ``minverlap'' gridding algorithm]{A sky grid of tiles defined using the ``minverlap'' gridding algorithm. The input parameters and colours are the same as in Figure~\ref{fig:product}. This grid contains 407 tiles.  Note the even spacing of tiles even over the $\alpha=0$ meridian, and the better coverage at the pole.}
\label{fig:minverlap}
\end{minipage}
\end{figure}

% ---------

\begin{figure}[p]
\begin{center}
\includegraphics[width=\linewidth]{images/spacing_cosine.pdf}
\end{center}
\caption[Tile spacing with the ``cosine'' algorithm]{Tile spacing with the ``cosine'' algorithm, with a \SI{13}{\degree}$\times$\SI{13}{\degree} FoV and $0.2$ overlap.
\\
\textbf{Left}: Equation~\ref{eq:product_deltadelta} gives $\Delta\delta = $ \SI{10.4}{\degree}, which does not divide into \SI{90}{\degree} without a remainder. 17 strips are defined moving away from $\delta=0$, with last being \SI{6.8}{\degree} from the poles. As this is less than half of the field of view (\SI{6.5}{\degree}) the poles themselves will not fall within the area of any tile.
\\
\textbf{Right}: Equation~\ref{eq:cosine_deltaalpha} gives $\Delta\alpha = $ \SI{10.4}{\degree} on the equator ($\delta=0$). This results in 35 tiles and a reduced spacing of \SI{6.4}{\degree} to the west of the $\alpha=0$ meridian. This remainder will be different for each strip as $\delta$ changes, as visible in Figure~\ref{fig:cosine}.
}
\label{fig:cosine_spacing}
\end{figure}

\begin{figure}[p]
\begin{center}
\includegraphics[width=\linewidth]{images/spacing_minverlap.pdf}
\end{center}
\caption[Tile spacing with the ``minverlap'' algorithm]{Tile spacing with the ``minverlap'' algorithm, with the same parameters as Figure~\ref{fig:cosine_spacing}.
\\
\textbf{Left:} Equation~\ref{eq:minverlap_deltadelta} gives $\Delta\delta = $ \SI{10}{\degree}, therefore neatly arranging 19 strips between \SI{-90}{\degree} and \SI{90}{\degree}.
\\
\textbf{Right:} Equation~\ref{eq:minverlap_deltaalpha} also gives $\Delta\alpha = $ \SI{10}{\degree} on the equator ($\delta=0$), so 36 tiles are uniformly arranged around the circumference of the sphere.
}
\label{fig:minverlap_spacing}
\end{figure}

\newpage

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\subsection{HEALPix and probability sky maps}
\label{sec:skymaps}
\begin{colsection}

\gls{healpix} is a system used to define pixelised data on the surface of a sphere~\citep{HEALPix}. Developed at NASA JPL for microwave background data, it is now widely used for other applications including for gravitational wave skymaps produced by the \gls{lvc}. HEALPix divides the sphere into a series of nested (hierarchical) equal-area (although not equal-shape) pixels arranged in declination strips (``isoLatitude''). Shown in Figure~\ref{fig:healpix} are the first four orders of spheres, starting from a base resolution with 12 pixels and increasing as each pixel is split into four. The resolution of the sphere is defined using the $N_\text{side}$ parameter, which is given by the number of pixels along the side of one of the 12 base pixels in the given resolution. At every resolution each base-resolution pixel contains $N_\text{side}^2$ pixels, so the total number of pixels in a sphere is given by

\begin{equation}
    N_\text{pix} = 12 N_\text{side}^2.
    \label{eq:healpix_npix}
\end{equation}

Each pixel therefore has an equal area of

\begin{equation}
    \Omega_\text{pix} = \frac{4\pi}{12 N_\text{side}^2} = \frac{\pi}{3 N_\text{side}^2},
    \label{eq:healpix_area}
\end{equation}

on a unit sphere where the radius $r=1$. Taking the celestial sphere, the circumference in degrees is $\SI{360}{\degree} = 2 \pi r$ meaning the area of the whole sky is given by

\begin{equation}
    A_\text{sky} = 4 \pi r^2 = 4 \pi \left ( \frac{\SI{360}{\degree}}{2 \pi} \right )^2 = \frac{129600}{\pi}~\text{sq deg} \approx 41252~\text{sq deg} , %chktex 3
    \label{eq:sky_area}
\end{equation}

and therefore the area of each HEALPix pixel is

\begin{equation}
    A_\text{pix} = \frac{129600}{12 \pi N_\text{side}^2}~\text{sq~deg} \approx \frac{3438}{N_\text{side}^2}~\text{sq~deg}.
    \label{eq:healpix_area_degrees}
\end{equation}

Figure~\ref{fig:healpix} shows only the first four orders of HEALPix pixelisation, up to $N_\text{side} = 8$ where the sphere is split into 768 pixels each with an area (which can be considered the resolution of the grid) of 53.7~sq deg. An initial, low-resolution \gls{lvc} skymap might use a grid with $N_\text{side} = 64$ (49 thousand pixels) and resolution (pixel area) of 0.84~sq~deg, where as a final output skymap will have $N_\text{side} = 1024$, 12.5 million pixels and a resolution of $3.27 \times 10^{-3}$~sq~deg (11.7 square arcminutes).

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.7\linewidth]{images/healpix.pdf}
\end{center}
\caption[HEALPix partitions of a sphere]{HEALPix partitions of a sphere, of increasing order and $N_\text{side}$ resolution parameter. Note that as the resolution increases each pixel on the previous sphere is split into four on the new sphere, and $N_\text{side}$ is the number of pixels along the side of a base-resolution pixel (two of which are highlighted). Adapted (colourised) from Figure~4 of \citet{HEALPix}.
}
\label{fig:healpix}
\end{figure}

In addition to being a way to divide the sphere, each HEALPix pixel has a unique index from one of two different numbering schemes: either the ring (counting around each ring from the north to the south) or nested (based on the sub-pixel tree) system. Each scheme has its own advantages, ring-indexed grids are easier to apply spherical harmonics to while nested grids are easier to enter into hierarchical databases. Ultimately for astronomical sky maps the harmonics are less relevant and so nested grids are usually used, but conversion between the two is fairly straightforward.

HEALPix is used to provide localisation of sky probabilities for transient astronomical events, in the form of sky maps. Each point on the HEALPix grid is assigned a probability between 0 and 1 that the counterpart object is located within that pixel, and the whole sphere should sum to unity. Figure~\ref{fig:example_skymap} shows an example \gls{lvc} skymap, produced as part of the ``First Two Years'' simulations \citep{First2Years}.

\begin{figure}[p]
\begin{center}
\includegraphics[width=\linewidth]{images/skymap_plot.pdf}
\end{center}
\caption[An example low-resolution skymap]{An example low-resolution gravitational wave skymap. The original skymap has been deliberately downgraded from $N_\text{side} = 256$ to $N_\text{side} = 32$ ($N_\text{pix} = 12288$) so that individual HEALPix pixels are visible. Each point is assigned a probability value as shown by the colour scale, which indicates the contained probability within that pixel.
}
\label{fig:example_skymap}
\end{figure}

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\subsection{Mapping sky maps to sky grids}
\label{sec:mapping_skymaps}
\begin{colsection}

When gravitational wave signals are detected the \gls{lvc} analysis pipelines create HEALPix sky maps to describe the sky localisation, and these are then distributed with the public VOEvent (see Section~\ref{sec:voevents}). GOTO-tile uses these skymaps to produce follow-up targets for \gls{goto}. This is done by mapping the sky maps onto the previously-defined all-sky grid used for the all-sky survey. As described previously in Section~\ref{sec:grids}, these grids are defined by a series of tiles covering the celestial sphere. GOTO-tile's task is to find all of the HEALPix points that fall within each tile, and then summing the probability values for each of these points gives the contained probability within the tile.

The first step to finding the probability contained within a tile is to define the edges of the tile in terms of celestial coordinates. This is done using the \code{get\_tile\_vertices} function within \pkg{gototile} written by Evert Rol. After that a polygon is defined that matches the tile area, and then using the \pkg{healpy} \code{query\_polygon} function the indices of the HEALPix points within each tile are found. This of course differs depending on the resolution required, and so is only calculated when applying a sky map with a defined $N_\text{side}$ to the previously-generated grid. Once it's found which HEALPix points are within a given tile it's easy to mask the skymap HEALPix array and sum the probability of these points, which gives the total contained probability within each tile.

Figure~\ref{fig:170817_gw} shows an example of GOTO-tile applied to the sky map for the GW170817 event (\cite{GW170817}). The points within each tile were identified and summed in order to find the total contained probability within each tile. There is some redundancy due to the overlap between tiles, however this is typically negligible (the final GW170817 sky map used was notably smaller than usual LVC sky maps due to the coincident \textit{Fermi} localisation, which makes the overlaps more pronounced).

\begin{figure}[p]
\begin{center}
\includegraphics[width=\linewidth]{images/skymaps_170817_gw.pdf}
\end{center}
\caption[Tile probabilities for GW170817]{Tile probabilities using the final sky map for GW170817 (\cite{GW170817}). The sphere shows the whole skymap for this event, with each pixel coloured by probability, and the location of the source of the event is shown with the blue star. Overlaid is the GOTO-4 sky grid, with tiles of \SI{3.7}{\degree} $\times$ \SI{4.9}{\degree} and overlap of $0.1$. The inset shows the tiles coloured by their contained probability (the sum of all pixels within). The four tiles with contained probability of higher than 5\% are highlighted in red.
}
\label{fig:170817_gw}
\end{figure}

\newpage

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\subsection{Creating sky maps for GRB events}
\label{sec:grb_skymaps}
\begin{colsection}

This system described in the previous sections works well for gravitational wave events using \gls{lvc} sky maps, and it has since ben expanded to other types of events. As part of the commissioning observations (\rtxt{see commissioning}) when the LIGO-Virgo detectors were down \gls{goto} also followed-up \gls{grb} events from the \textit{Fermi} satellite \gls{gbm} \citep{Fermi_GBM}. These events however do not include probability sky maps, instead they only include a central right ascension, declination and error radius. Yik Lun Mong and I developed code in order to create a sky map from these Fermi events, therefore allowing them to be processed by GOTO-tile using the same methods already created for gravitational wave events.

Instead of loading a sky map from a FITS file, a function was written to create a probability sky map based on a 2D Gaussian profile. First, the error radius ($r$, the 68\% containment radius) is converted into the standard deviation of the distribution $\sigma$ using

\begin{equation}
    \sigma = \frac{r}{\sqrt{2.3}}.
    \label{eq:gaussian_sigma}
\end{equation}

The distance $d$ between a given point on the sphere ($\alpha, \delta$) and the central coordinates of the distribution ($\alpha_c, \delta_c$) is given by

\begin{equation}
    \sin^2 \left ( \frac{1}{2} d \right )
    = \sin^2 \left ( \frac{\delta-\delta_c}{2} \right)
      + \cos (\delta) \cos (\delta_c) \sin^2 \left ( \frac{\alpha-\alpha_c}{2} \right),
    \label{eq:gaussian_distance}
\end{equation}

and the probability at each point is given by

\begin{equation}
    P(\alpha, \delta) = \frac{1}{2\pi\sigma} \exp \left ( \frac{d^2}{2\sigma^2} \right ).
    \label{eq:gaussian_prob}
\end{equation}

In order to create a HEALPix sky map this probability is calculated for every point on the grid, which creates the sky map array. This can then be processed with GOTO-tile exactly like an \gls{lvc} sky map.

Using this above method, sky maps can be created for any single-target alert that has a given error radius. Several sources of transient events, such as \textit{Gaia} or \textit{Swift}, produce very well-localised events with error regions well below the field of view of GOTO, so creating sky maps is less important. The sky maps for \glspl{grb} from \textit{Fermi} however cover much larger areas. For example, the \gls{gbm} detection of GRB~170817A that helped localise the GW170817 gravitational wave detection produced an initial alert with an error radius of \SI{17.45}{\degree}, later reduced to \SI{11.58}{\degree} in the final alert\footnote{GCN Notices available at \url{https://gcn.gsfc.nasa.gov/other/524666471.fermi}}, which corresponded to a 50\% confidence region of $\sim$500~square~degrees \citep{GW170817_Fermi}. The error values given in \gls{gbm} GCN Notices however only account for statistical errors for that event, not systematic errors. The \gls{gbm} systematic errors are described in \citet{Fermi_localisation} to be well modelled by a core Gaussian with a radius of \SI{3.71}{\degree} and a non-Gaussian tail extending to \SI{14}{\degree}. For the purposes of \gls{goto} tiling the tail is ignored, and a single Gaussian is produced with an error radius simply combining the statistical radius ($r_\text{notice}$) and this  systematic profile in quadrature as

\begin{equation}
    r = \sqrt{r_\text{notice}^2 + {(\SI{3.71}{\degree})}^2}.
    \label{eq:fermi_radius}
\end{equation}

This radius is then used with Equation~(\ref{eq:gaussian_sigma}) onwards to create the Gaussian sky map. It should be noted that in reality the probability areas from \textit{Fermi} are not perfectly symmetric Gaussian profiles, but until \gls{gbm} events start being published with \gls{healpix} sky maps this works as a reasonable approximation. For GRB~170817A the sky map and tiling solution is shown in Figure~\ref{fig:170817_grb}. Note that the source location falls quite far out of the peak of the \gls{grb} sky map, and had there not been the coincident gravitational wave detection it would be unlikely that the source of the gamma-ray burst would have been observed.

\begin{figure}[p]
\begin{center}
\includegraphics[width=\linewidth]{images/skymaps_170817_grb.pdf}
\end{center}
\caption[Tile probabilities for GRB 170817A]{Tile probabilities using the constructed Gaussian sky map for GRB 170817A (\cite{GW170817_Fermi}). As in Figure~\ref{fig:170817_gw} the sphere shows the skymap and the GOTO-4 grid, with the identified source of GW170817 shown by the blue star. The tiles highlighted in red each contain more than 1\% of the probability instead of 5\% used in Figure~\ref{fig:170817_gw}, due to the greater spread of the skymap meaning no tile here contains more than 5\%.
}
\label{fig:170817_grb}
\end{figure}

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\end{colsection}

% ########################################

\newpage
\section{Alert processing with GOTO-alert}
\label{sec:gotoalert}
\begin{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\begin{colsection}

GOTO-alert is another \proglang{Python} module (\pkg{gotoalert} \rtxt{footnote url?}) created for the \gls{goto} project to contain functions related to alert handling and VOEvents. It was originally created based on code written by Alex Obradovic (a student at Monash) for \gls{grb} events. After he uploaded his code I reworked it into an object-oriented Python module and integrated it into the wider \gls{goto} software ecosystem, specifically adding in functions related to the GOTO-tile and ObsDB modules.

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\subsection{GCN alerts}
\label{sec:gcn}
\begin{colsection}

The \gls{gcn}, also known as the Transient Astronomy Network or together GCN/TAN, is a system hosted by NASA originally to publish alerts relating to gamma-ray burst detections \citep{GCN}. It publishes events from a variety of telescopes including \textit{INTEGRAL}, \textit{Fermi} and \textit{Swift}, and more recently has expanded to neutrino and gravitational wave alerts --- including publishing alerts from the LIGO-Virgo Collaboration.

Alerts are produced by the projects and missions in the form of \gls{gcn} Notices, standard machine-readable text messages that are distributed by the network. Notices are designed to be written and sent out automatically by the instrument without the need for human intervention, and likewise can be received and acted on by automated systems run by follow-up projects such as \gls{goto}'s sentinel. Transmitting notices is only done by the projects that are part of the network.

There is a second form of alerts distributed by the network called \gls{gcn} Circulars. Unlike notices, circulars are designed to be written by humans and sent out by email to anyone subscribed to the distribution list. They act as a formal, citable way to share information about events: both the detection by the instrument but also follow-up activity from other groups.

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\subsection{VOEvents}
\label{sec:voevents}
\begin{colsection}

The GCN/TAN system broadcasts notices in multiple ways over many different channels, but the most useful for automated telescopes such as \gls{goto} uses the \gls{ivoa} VOEvent standard \citep{voevent}. VOEvents are a standard way to transmit information about transient astronomical events, in a structured format to make the reports easily machine-readable. Each event is assigned an \gls{ivorn} and follows a defined schema. By defining a standard template to follow diverse events can all be universally processed and robotic telescopes triggered without the need for human interpretation or vetting.

The structure to transmit these events is fairly flexible, but there are certain common roles. The names below are taken from \citet{voevent}:

\begin{itemize}
    \item \textbf{Authors} are the projects, instruments or institutions that create the original data worthy of reporting in the VOEvent.
    \item \textbf{Publishers} take the information about the astronomical event, put it into the VOEvent format and broadcast it from their servers.
    \item \textbf{Brokers} act as nodes in the communication web, they can take in events from multiple publishers and rebroadcast them in a single stream.
    \item \textbf{Subscribers} are the end users that listen to VOEvent servers (either directly to the publishers or a common broker).
\end{itemize}

In some cases roles can be combined, but for the case of \gls{goto} receiving \gls{lvc} events there are distinct actors: the LIGO-Virgo Collaboration is the author, NASA and the GCN/TAN system are the publishers and the \gls{goto} sentinel is the subscriber.

It is possible to listen directly to the GCN/TAN servers, in which case the sentinel would receive VOEvents from the NASA missions and other projects like \gls{ligo}. However there are other groups out there publishing their own VOEvents separate to the GCN system which we might want to receive. It would be possible to run multiple event listeners within the sentinel, each listening to other servers, but it is much easier to listen to a common broker that already does that and provides a single point of access to these pipelines. The broker chosen for the \gls{gtecs} sentinel is the same as for pt5m: the 4 Pi Sky VOEvents Hub \citep{4pisky}.

4 Pi Sky provides alerts from the GCN system\footnote{\url{https://gcn.gsfc.nasa.gov/burst_info.html}} as well as from the Gaia\footnote{\url{http://gsaweb.ast.cam.ac.uk/alerts/alertsindex}} and \gls{asassn}\footnote{\url{http://www.astronomy.ohio-state.edu/~assassin/transients}} projects. At the time of writing \gls{goto} only follows up \gls{lvc} \gls{gw} as well as \textit{Fermi} and \textit{Swift} \gls{grb} events, all of which are published through \glspl{gcn}, meaning there's technically no benefit of listening to 4 Pi Sky over listening directly to NASA.\@ However pt5m automatically followed up Gaia events meaning the 4 Pi Sky broker was necessary, and it has been suggested \gls{goto} could do the same.

In order to receive VOEvents from any source it is necessary to set up a VOEvent client. The most common way to do this is using the \software{Comet} software \citep{comet}, which allows both sending and receiving of events. For the \gls{gtecs} sentinel (see Section~\ref{sec:sentinel}) all that was needed was a simple way to listen to and download alerts, which is why it instead uses code based on the \software{Python} module PyGCN (\pkg{pygcn}\footnote{\url{https://github.com/lpsinger/pygcn}}). Despite the name, PyGCN works perfectly fine to receive any VOEvents, not just those from the GCN servers. The sentinel uses PyGCN to open a socket to the 4 Pi Sky server and ingest binary packets, as well as sending the required receipt and ``\code{iamalive}'' responses to the server to ensure it keeps receiving events.

VOEvents take the form of a structured \gls{xml} document. \gls{xml} is a ``markup'' language similar to HTML, JSON or \LaTeX, meaning it is understandable by humans but follows a set schema and so can be easily read and processed by computers. A sample of a VOEvent is given in Figure~\ref{fig:voevent_xml}.

\begin{figure}[p]
\begin{lstlisting}[language=xml,
       tabsize=2,
       breaklines=true,
       keywordstyle={},
       stringstyle=\color{red},
       showstringspaces=false,
       basicstyle=\scriptsize,
       emph={voe,Who,What,WhereWhen,How,Citations},
       emphstyle={\color{magenta}}
       ]
<?xml version=\'1.0\'
      encoding=\'UTF-8\'?>\n<voe:VOEvent
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:voe="http://www.ivoa.net/xml/VOEvent/v2.0"
      xsi:schemaLocation="http://www.ivoa.net/xml/VOEvent/v2.0
                          http://www.ivoa.net/xml/VOEvent/VOEvent-v2.0.xsd"
      role="observation"
      ivorn="ivo://gwnet/LVC#S190408an-2-Initial">
<Who>
 <Date>2019-04-08T20:21:42</Date>
 <Author>
  <contactName>LIGO Scientific Collaboration and Virgo Collaboration</contactName>
 </Author>
</Who>
<What>
 <Param name="Packet_Type" dataType="int" value="151"></Param>
 <Param name="internal" dataType="int" value="0"></Param>
 <Param name="Pkt_Ser_Num" dataType="string" value="2"></Param>
 <Param name="GraceID" dataType="string" value="S190408an" ucd="meta.id"></Param>
 <Param name="AlertType" dataType="string" value="Initial" ucd="meta.version"></Param>
 <Param name="HardwareInj" dataType="int" value="0" ucd="meta.number"></Param>
 <Param name="OpenAlert" dataType="int" value="1" ucd="meta.number"></Param>
 <Param name="EventPage" dataType="string" value="https://gracedb.ligo.org/superevents/S190408an/view/" ucd="meta.ref.url"></Param>
 <Param name="Instruments" dataType="string" value="H1,L1,V1" ucd="meta.code"> </Param>
 <Param name="FAR" dataType="float" value="2.81096164616e-18" ucd="arith.rate;stat.falsealarm" unit="Hz"></Param>
 <Param name="Group" dataType="string" value="CBC" ucd="meta.code"></Param>
 <Param name="Pipeline" dataType="string" value="gstlal" ucd="meta.code"></Param>
 <Param name="Search" dataType="string" value="AllSky" ucd="meta.code"></Param>
 <Group type="GW_SKYMAP" name="bayestar">
  <Param name="skymap_fits" dataType="string" value="https://gracedb.ligo.org/api/superevents/S190408an/files/bayestar.fits.gz" ucd="meta.ref.url"></Param>
 </Group>
 <Group type="Classification">
  <Param name="BNS" dataType="float" value="0.0" ucd="stat.probability"></Param>
  <Param name="NSBH" dataType="float" value="0.0" ucd="stat.probability"></Param>
  <Param name="BBH" dataType="float" value="0.99999999999" ucd="stat.probability"></Param>
  <Param name="MassGap" dataType="float" value="0.0" ucd="stat.probability"></Param>
  <Param name="Terrestrial" dataType="float" value="9.82357724531e-12" ucd="stat.probability"></Param>
 </Group>
 <Group type="Properties">
  <Param name="HasNS" dataType="float" value="0.0" ucd="stat.probability"></Param>
  <Param name="HasRemnant" dataType="float" value="0.12" ucd="stat.probability"></Param>
 </Group>
</What>
<WhereWhen>
 <ObsDataLocation>
 <ObservatoryLocation id="LIGO Virgo"/>
 <ObservationLocation>
 <AstroCoordSystem id="UTC-FK5-GEO"/>
 <AstroCoords coord_system_id="UTC-FK5-GEO">
 <Time><TimeInstant><ISOTime>2019-04-08T18:18:02.288180</ISOTime></TimeInstant></Time>
 </AstroCoords>
 </ObservationLocation>
 </ObsDataLocation>
</WhereWhen>
...
\end{lstlisting}
\caption[VOEvent XML sample]{A sample of VOEvent \gls{xml} text from an \gls{lvc} event, formatted so the core \gls{xml} structure is visible. Some of the key pieces of information are the role and \gls{ivorn} defined in the header, the URL of the sky map and the event classification probabilities.
}
\label{fig:voevent_xml}
\end{figure}

\newpage

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\subsection{Event handling}
\label{sec:event_handling}
\begin{colsection}

Once the VOEvent is received by the \gls{gtecs} sentinel the work of parsing and processing the event uses another \proglang{Python} module GOTO-Alert (\pkg{gotoalert}).

At the core of the GOTO-alert code is the \code{Event} object class. An Event is created from a raw binary payload from the PyGCN VOEvent client, and from the \gls{xml} a \proglang{Python} class is populated with the event information (\gls{ivorn}, type, source etc). Once the basic Event is created it is checked against an internal list of so-called ``interesting'' event packet types --- the ones we care about processing for \gls{goto}. At the time of writing these are \code{SWIFT\_BAT}, \code{FERMI\_GBM} and \code{LVC} events. Should the event not match any of the recognised packet types is is flagged and wil lbe rejected by the handler. If it does match one of the interesting types however then further information is filled out. For example, if it is an \gls{lvc} gravitational wave event then it should have a \code{skymap\_fits} parameter which gives a URL for where the sky map can be downloaded from GraceDB, the \gls{ligo} event database (as shown in Figure~\ref{fig:voevent_xml}). On the other hand if it is a gamma-ray bust event it should contain a sky position in right ascension and declination as well as an error radius. These attributes are parsed and stored as attributes of the \code{Event} class on creation.

Once the Event has been created the sentinel runs it through the GOTO-alert \code{event\_handler} function. This function carries out three primary tasks:
\begin{enumerate}
    \item Filter out uninteresting events. There are several possible filters, such as disallowing events too close to the galactic plane, but the two key ones are filtering by role (only events marked \code{observation} are allowed through, other roles include \code{utility} or \code{test}) and type (as noted when creating the Event currently only gravitational wave and selected gamma-ray busts are allowed). Should it fail to pass the filters then the function returns at this stage.
    \item If the event passes the filters then the \code{db\_insert} function is called to create and insert pointings into the observation database (see below).
    \item Finally, GOTO-alert also contains functions for checking observability at predefined sites and creating webpages for each event. These are based on Alex Obradovic's original GOTO-alert code and are not currently used by the live version running on La Palma.
\end{enumerate}

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\subsection{Inserting events into the observation database}
\label{sec:db_insert}
\begin{colsection}

The most important job of the sentinel is to insert events into the observation database so they are visible to the scheduler (see Sections~\ref{sec:obsdb}~\&~\ref{sec:scheduler}). This is done within the event handler by the \code{db\_insert} function.

The first thing the \code{db\_insert} function does is check for existing records for this event in the observing database \code{Events} table. This is to account for updating events as revised VOEvent alerts are received. For example, \gls{lvc} events have several stages: first a ``Preliminary'' alert is released as soon as the signal is detected, then an ``Initial'' alert is issued when it has been human-vetted. From then future versions are marked as ``Update'' alert, unless the event itself is found to be non-physical or below certain thresholds in which case a ``Retraction'' alert is issued. At any of these stages the event sky map might be modified shifting the observing area, and \gls{goto} needs to update to these changes. Therefore if a previous entry for a new event is detected then all of the old pointings that are still pending in the queue are deleted before the new ones are added.

Once previous event have been dealt with then the new entries in the database need to be created. All \gls{goto} pointings from the sentinel are defined \textit{on-grid}, meaning that they need to be mapped to the current GOTO-tile sky grid (see Section~\ref{sec:grids}). The database \code{Grids} table contains the field of view and overlap parameters of the current grid, allowing it to be reconstructed using GOTO-tile within the event handler. Once a GOTO-tile \code{SkyGrid} class has been created then a corresponding \code{SkyMap} is made based on the information in the event. If it was created from a gravitational wave alert then it should have a URL to download the \gls{lvc}-created sky map. If instead it just has a coordinate and error radius, i.e.\ a \gls{grb} alert, then a new Gaussian sky map is constructed as described in Section~\ref{sec:grb_skymaps}. Once both are ready then the sky map is mapped onto the grid simply using the attribute \code{SkyGrid.apply\_skymap(SkyMap)}, which returns a table of tiles and associated contained probabilities. %chktex 36

The tile probability table created by GOTO-tile contains entries for every tile within the all-sky grid, of which a vast majority will contain a very small amount of the overall probability for any reasonably-well located sky map. Therefore before adding anything to the database the tile table is masked to exclude all but the highest probability tiles. The limit is configurable depending on the event type. For gravitational wave events which are \gls{goto}'s highest priority all tiles which contain more than 1\% of the overall sky map probability. \gls{grb} events however, although still interesting, are a lower priority and therefore only the top 5 most probable tiles are inserted into the database and only if they contain more than 5\% of the overall probability. It is not uncommon to receive very poorly-localised \textit{Fermi} events where no tiles pass these criteria, in which case no pointings end up being inserted.

Once the tile list has been trimmed down to only the ones worth observing, then entries can be inserted into the database. First a new entry in the \code{Events} table is added for this event, containing the source, type, ID and \gls{ivorn}. Then an entry in the \code{Surveys} table is also created in order to group together all the pointings from this particular event. Although it is currently not used, the database is defined to allow multiple surveys per event. For example, there could be a quick initial survey in a wide-passband filter that prioritises possible host galaxies followed by a slower survey using the colour filters and longer exposure times that focuses on covering the sky map. But at the time of writing each event only has a single survey defined.

Finally the individual tiles are inserted as entries in the \code{Mpointings} table. Each is connected to an entry in the \code{GridTiles} table for this particular grid, and the tile probabilities are stored as corresponding entries in the \code{SurveyTiles} table. The most important entries for the mpointings are the rank, target constraint values (minimum altitude, moon phase etc), the time block parameters (the time between pointings being valid) and the actual exposure settings (exposure time, filter, number in a set). These can also be varied depending on the type of event, with \gls{gw} events being inserted at the highest ranks and with the most lenient constraints. Then once the mpointings are defined the first pointings are also created and added to the database \code{Pointings} table, to insure they become immediately valid in the queue without having to wait for the caretaker to create them.

Once all those entries are added to the database then the event has been successfully handled. The only other thing the sentinel will do is send out a \software{Slack} message to the \gls{goto} channel, to register that is has processed an alert and report which tiles have been triggered for observation. When the scheduler next fetches the queue the pointings should be there ready to observe, and if they are valid they will be sent to the pilot to begin follow-up observations.

\end{colsection}

% ~~~~~~~~~~~~~~~~~~~~

\end{colsection}

% ########################################
